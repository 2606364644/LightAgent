"""
File system access tools for agents

Provides comprehensive file system operations including:
- File reading and writing
- Directory navigation and listing
- File searching
- Path operations
All with safety checks and error handling
"""
import os
import aiofiles
from typing import Any, Dict, List, Optional
from pathlib import Path
from pydantic import BaseModel, Field
from .base import BaseTool, FunctionTool


class SafePathConfig(BaseModel):
    """Configuration for safe file system access"""
    allowed_roots: List[str] = Field(default_factory=list)
    deny_patterns: List[str] = Field(default_factory=list)
    max_file_size: int = 10 * 1024 * 1024  # 10MB default


class FileToolConfig(BaseModel):
    """Configuration for file tools"""
    safe_mode: bool = True
    path_config: Optional[SafePathConfig] = None


def validate_path_safe(path: str, config: SafePathConfig) -> tuple[bool, Optional[str]]:
    """
    Validate that a path is safe to access

    Args:
        path: Path to validate
        config: SafePathConfig instance

    Returns:
        Tuple of (is_safe, error_message)
    """
    if not config.allowed_roots:
        return True, None

    try:
        abs_path = os.path.abspath(path)

        # Check if path is under allowed roots
        for root in config.allowed_roots:
            abs_root = os.path.abspath(root)
            if abs_path.startswith(abs_root + os.sep) or abs_path == abs_root:
                return True, None

        return False, f"Path '{path}' is not under allowed roots"

    except Exception as e:
        return False, f"Path validation error: {str(e)}"


async def read_file(
    path: str,
    encoding: str = 'utf-8',
    config: Optional[FileToolConfig] = None
) -> Dict[str, Any]:
    """
    Read file contents

    Args:
        path: File path
        encoding: File encoding (default: utf-8)
        config: FileToolConfig instance

    Returns:
        Dictionary with file content or error
    """
    try:
        # Validate path if in safe mode
        if config and config.safe_mode and config.path_config:
            is_safe, error = validate_path_safe(path, config.path_config)
            if not is_safe:
                return {
                    'success': False,
                    'error': error,
                    'path': path
                }

        # Check file size
        file_size = os.path.getsize(path)
        if config and config.path_config and file_size > config.path_config.max_file_size:
            return {
                'success': False,
                'error': f'File too large: {file_size} bytes (max: {config.path_config.max_file_size})',
                'path': path
            }

        # Read file
        async with aiofiles.open(path, 'r', encoding=encoding) as f:
            content = await f.read()

        return {
            'success': True,
            'content': content,
            'path': path,
            'size': file_size,
            'encoding': encoding
        }

    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'path': path
        }


async def write_file(
    path: str,
    content: str,
    encoding: str = 'utf-8',
    config: Optional[FileToolConfig] = None
) -> Dict[str, Any]:
    """
    Write content to file

    Args:
        path: File path
        content: Content to write
        encoding: File encoding (default: utf-8)
        config: FileToolConfig instance

    Returns:
        Dictionary with success status
    """
    try:
        # Validate path if in safe mode
        if config and config.safe_mode and config.path_config:
            is_safe, error = validate_path_safe(path, config.path_config)
            if not is_safe:
                return {
                    'success': False,
                    'error': error,
                    'path': path
                }

        # Create directory if it doesn't exist
        directory = os.path.dirname(path)
        if directory:
            os.makedirs(directory, exist_ok=True)

        # Write file
        async with aiofiles.open(path, 'w', encoding=encoding) as f:
            await f.write(content)

        return {
            'success': True,
            'path': path,
            'bytes_written': len(content.encode(encoding))
        }

    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'path': path
        }


async def list_directory(
    path: str,
    recursive: bool = False,
    include_hidden: bool = False,
    config: Optional[FileToolConfig] = None
) -> Dict[str, Any]:
    """
    List directory contents

    Args:
        path: Directory path
        recursive: List recursively
        include_hidden: Include hidden files/directories
        config: FileToolConfig instance

    Returns:
        Dictionary with directory contents
    """
    try:
        # Validate path if in safe mode
        if config and config.safe_mode and config.path_config:
            is_safe, error = validate_path_safe(path, config.path_config)
            if not is_safe:
                return {
                    'success': False,
                    'error': error,
                    'path': path
                }

        items = []
        path_obj = Path(path)

        if recursive:
            # Recursive listing
            for item in path_obj.rglob('*'):
                if not include_hidden and item.name.startswith('.'):
                    continue

                items.append({
                    'name': item.name,
                    'path': str(item),
                    'type': 'directory' if item.is_dir() else 'file',
                    'size': item.stat().st_size if item.is_file() else None
                })
        else:
            # Non-recursive listing
            for item in path_obj.iterdir():
                if not include_hidden and item.name.startswith('.'):
                    continue

                items.append({
                    'name': item.name,
                    'path': str(item),
                    'type': 'directory' if item.is_dir() else 'file',
                    'size': item.stat().st_size if item.is_file() else None
                })

        return {
            'success': True,
            'path': path,
            'items': items,
            'count': len(items)
        }

    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'path': path
        }


async def search_files(
    path: str,
    pattern: str = '*',
    content_pattern: Optional[str] = None,
    config: Optional[FileToolConfig] = None
) -> Dict[str, Any]:
    """
    Search for files by name and/or content

    Args:
        path: Root directory to search
        pattern: File name pattern (e.g., '*.py', '*.txt')
        content_pattern: Optional content pattern to search for
        config: FileToolConfig instance

    Returns:
        Dictionary with search results
    """
    try:
        # Validate path if in safe mode
        if config and config.safe_mode and config.path_config:
            is_safe, error = validate_path_safe(path, config.path_config)
            if not is_safe:
                return {
                    'success': False,
                    'error': error,
                    'path': path
                }

        matches = []
        path_obj = Path(path)

        for file_path in path_obj.rglob(pattern):
            if not file_path.is_file():
                continue

            match_info = {
                'path': str(file_path),
                'name': file_path.name
            }

            # Search content if pattern provided
            if content_pattern:
                try:
                    async with aiofiles.open(file_path, 'r', encoding='utf-8') as f:
                        content = await f.read()

                    if content_pattern.lower() in content.lower():
                        match_info['content_matches'] = content.lower().count(content_pattern.lower())
                        matches.append(match_info)

                except Exception:
                    # Skip files that can't be read as text
                    continue
            else:
                matches.append(match_info)

        return {
            'success': True,
            'path': path,
            'pattern': pattern,
            'content_pattern': content_pattern,
            'matches': matches,
            'count': len(matches)
        }

    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'path': path
        }


async def get_file_info(path: str, config: Optional[FileToolConfig] = None) -> Dict[str, Any]:
    """
    Get detailed file information

    Args:
        path: File path
        config: FileToolConfig instance

    Returns:
        Dictionary with file information
    """
    try:
        # Validate path if in safe mode
        if config and config.safe_mode and config.path_config:
            is_safe, error = validate_path_safe(path, config.path_config)
            if not is_safe:
                return {
                    'success': False,
                    'error': error,
                    'path': path
                }

        path_obj = Path(path)
        stat = path_obj.stat()

        info = {
            'success': True,
            'path': path,
            'name': path_obj.name,
            'type': 'directory' if path_obj.is_dir() else 'file',
            'size': stat.st_size,
            'created': stat.st_ctime,
            'modified': stat.st_mtime,
            'accessed': stat.st_atime,
            'absolute_path': str(path_obj.absolute())
        }

        # Add extension for files
        if path_obj.is_file():
            info['extension'] = path_obj.suffix

        return info

    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'path': path
        }


async def create_directory(
    path: str,
    parents: bool = True,
    config: Optional[FileToolConfig] = None
) -> Dict[str, Any]:
    """
    Create a directory

    Args:
        path: Directory path
        parents: Create parent directories if needed
        config: FileToolConfig instance

    Returns:
        Dictionary with success status
    """
    try:
        # Validate path if in safe mode
        if config and config.safe_mode and config.path_config:
            is_safe, error = validate_path_safe(path, config.path_config)
            if not is_safe:
                return {
                    'success': False,
                    'error': error,
                    'path': path
                }

        path_obj = Path(path)
        path_obj.mkdir(parents=parents, exist_ok=True)

        return {
            'success': True,
            'path': path,
            'created': True
        }

    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'path': path
        }


def create_read_file_tool(config: Optional[FileToolConfig] = None) -> BaseTool:
    """Create a read file tool"""
    if config is None:
        config = FileToolConfig()

    return FunctionTool(
        name='read_file',
        description='Read the contents of a file. Returns file content as text.',
        func=lambda path, encoding='utf-8': read_file(path, encoding, config),
        parameters={
            'type': 'object',
            'properties': {
                'path': {
                    'type': 'string',
                    'description': 'Path to the file to read'
                },
                'encoding': {
                    'type': 'string',
                    'description': 'File encoding (default: utf-8)',
                    'default': 'utf-8'
                }
            },
            'required': ['path']
        }
    )


def create_write_file_tool(config: Optional[FileToolConfig] = None) -> BaseTool:
    """Create a write file tool"""
    if config is None:
        config = FileToolConfig()

    return FunctionTool(
        name='write_file',
        description='Write content to a file. Creates the file and parent directories if they do not exist.',
        func=lambda path, content, encoding='utf-8': write_file(path, content, encoding, config),
        parameters={
            'type': 'object',
            'properties': {
                'path': {
                    'type': 'string',
                    'description': 'Path to the file to write'
                },
                'content': {
                    'type': 'string',
                    'description': 'Content to write to the file'
                },
                'encoding': {
                    'type': 'string',
                    'description': 'File encoding (default: utf-8)',
                    'default': 'utf-8'
                }
            },
            'required': ['path', 'content']
        }
    )


def create_list_directory_tool(config: Optional[FileToolConfig] = None) -> BaseTool:
    """Create a list directory tool"""
    if config is None:
        config = FileToolConfig()

    return FunctionTool(
        name='list_directory',
        description='List contents of a directory. Can list recursively.',
        func=lambda path, recursive=False, include_hidden=False: list_directory(path, recursive, include_hidden, config),
        parameters={
            'type': 'object',
            'properties': {
                'path': {
                    'type': 'string',
                    'description': 'Path to the directory'
                },
                'recursive': {
                    'type': 'boolean',
                    'description': 'List directories recursively',
                    'default': False
                },
                'include_hidden': {
                    'type': 'boolean',
                    'description': 'Include hidden files and directories',
                    'default': False
                }
            },
            'required': ['path']
        }
    )


def create_search_files_tool(config: Optional[FileToolConfig] = None) -> BaseTool:
    """Create a search files tool"""
    if config is None:
        config = FileToolConfig()

    return FunctionTool(
        name='search_files',
        description='Search for files by name pattern and optionally by content pattern.',
        func=lambda path, pattern='*', content_pattern=None: search_files(path, pattern, content_pattern, config),
        parameters={
            'type': 'object',
            'properties': {
                'path': {
                    'type': 'string',
                    'description': 'Root directory to search in'
                },
                'pattern': {
                    'type': 'string',
                    'description': 'File name pattern (e.g., *.py, *.txt)',
                    'default': '*'
                },
                'content_pattern': {
                    'type': 'string',
                    'description': 'Optional text pattern to search for within file contents'
                }
            },
            'required': ['path']
        }
    )


def create_get_file_info_tool(config: Optional[FileToolConfig] = None) -> BaseTool:
    """Create a get file info tool"""
    if config is None:
        config = FileToolConfig()

    return FunctionTool(
        name='get_file_info',
        description='Get detailed information about a file or directory including size, timestamps, etc.',
        func=lambda path: get_file_info(path, config),
        parameters={
            'type': 'object',
            'properties': {
                'path': {
                    'type': 'string',
                    'description': 'Path to the file or directory'
                }
            },
            'required': ['path']
        }
    )


def create_directory_tool(config: Optional[FileToolConfig] = None) -> BaseTool:
    """Create a create directory tool"""
    if config is None:
        config = FileToolConfig()

    return FunctionTool(
        name='create_directory',
        description='Create a directory. Can create parent directories if needed.',
        func=lambda path, parents=True: create_directory(path, parents, config),
        parameters={
            'type': 'object',
            'properties': {
                'path': {
                    'type': 'string',
                    'description': 'Path of the directory to create'
                },
                'parents': {
                    'type': 'boolean',
                    'description': 'Create parent directories if they do not exist',
                    'default': True
                }
            },
            'required': ['path']
        }
    )


def create_file_tools(
    config: Optional[FileToolConfig] = None
) -> List[BaseTool]:
    """
    Create a list of all file system tools

    Args:
        config: Optional FileToolConfig for safety settings

    Returns:
        List of BaseTool instances
    """
    return [
        create_read_file_tool(config),
        create_write_file_tool(config),
        create_list_directory_tool(config),
        create_search_files_tool(config),
        create_get_file_info_tool(config),
        create_directory_tool(config)
    ]
